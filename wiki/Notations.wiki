#summary notations used in this project
= Voxel Neighbors =
In the implementation of this project, the 3x3x3 neighborhood situation of a voxel is represented by a 32-bit integer whose lower 27 bits show whether the corresponding position is foreground (black) or background (white) by the bit '1' or '0', respectively.

The assignment of the neighboring points to the bit positions is as follows:

[http://simple-voxels.googlecode.com/svn/wiki/images/neighbor-bits.png]

== Implementation ==
A set of macro functions is defined to make an integer from the bit patterns of a 3x3x3 configuration:

{{{
    const int bits = BV( BP(0,0,0), BP(0,2,0), BP(0,0,0) );
}}}

where BV() and BP() macro names stand for "bit volume" and "bit plane", respectively.
The numbers in BP() represents the consecutive three bits of each line in the plane.

For example, the "bits" in the above represents the configuration
where the center voxel is the only voxel that is in the foreground (black, 1) while all the other voxels are in the background (white, 0).

The first BP() corresponds to the top plane in red,
and the second and the third BP() correspond to the mid and the bottom plane in green and blue, respectively.

For example, an integer defined as follows corresponds to the 3x3x3 configuration in the figure below, where the foreground voxels of the same color are on the same plane.
{{{
    const int bits = BV( BP(0,1,2), BP(3,4,5), BP(6,7,0) );
}}}

[http://simple-voxels.googlecode.com/svn/wiki/images/neighbor-hihumi.png]

Also, DumpBits() function can be used to print the configuration on the console.
{{{
    DumpBits( BV( BP(0,1,2), BP(3,4,5), BP(6,7,0) ) );
}}}
[http://simple-voxels.googlecode.com/svn/wiki/images/cout-neighbor-hihumi.png]

The foreground voxels are printed as 'o', and the background voxels as '.'.
As can be seen, configurations are printed plane-by-plane from the top to the bottom.

= Template Mask =
To check if a voxel is deletable or not in actual implementations,
3x3x3 template matching is one of the most commonly employed method.
In this project, _Mask_ structure defined in _Mask.h_ is used to define such template masks.
{{{
struct Mask {
    Mask( int _mask, int _value, int _nzero1 = 0, int _nzero2 = 0 );
    int mask;
    int value;
    int nzero1, nzero2;
    bool Match( int bits ) const {
        return (mask & bits) == value
            && (nzero1 == 0 || (bits & nzero1) != 0)
            && (nzero2 == 0 || (bits & nzero2) != 0);
    }
};
}}}
In this structure,
  * _mask_ defines the mask of interested bits that will be compared with _value_.
  * _nzero1_ and _nzero2_ are the masks that, if not zero, will be used to check whether at least one of the masked bits is 1 or not.

For example, the code below defines Palagyi's M1 mask and its variant by Raynal.
{{{
    const Mask Palagyi_M1(
        BV( BP(7,7,7), BP(0,2,0), BP(0,2,0) ),    // mask
        BV( BP(0,0,0), BP(0,2,0), BP(0,2,0) ),    // value
        BV( BP(0,0,0), BP(7,5,7), BP(7,5,7) )     // nzero1
    );
    const Mask Raynal_M1(
        BV( BP(7,7,7), BP(0,2,0), BP(0,2,0) ),    // mask
        BV( BP(0,0,0), BP(0,2,0), BP(0,2,0) )     // value
    );
}}}
By using DumpMask() function, the mask can be output to the console window.
{{{
    DumpMask( Palagyi_M1 );
    DumpMask( Raynal_M1 );
}}}
[http://simple-voxels.googlecode.com/svn/wiki/images/cout-template-masks.png]
|| *Character* || *Mask member* || *Description* ||
|| o || mask & value || black point ||
|| . || mask & ~value || white point ||
|| ' ' ||  || don't care ||
|| x || nzero1 || at least one x position should be black ||
|| + || nzero2 || at least one + position should be black ||


= Directions =
[http://simple-voxels.googlecode.com/svn/wiki/images/6directions.png]