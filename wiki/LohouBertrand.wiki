#summary Lohou and Bertrand P2x-simple thinning algorithm
*Contents*
<wiki:toc max_depth="2" />

= Introduction =
By using [RaynalCouprie Raynal and Couprie]'s method,
a considerable amount of spurious brances will be suppressed.
In addition, as was suggested in [Top#References [2]],
if the [RaynalCouprie#Isthmus_Points isthmus points] were not preserved but deleted,
the skeletal branches would also be removed resulting in _ultimate thinning_,
where no more points can be removed without breaking the object topology.
An ultimately thinned object has no branches and is composed of circular curves or cocoon like shells only.

However, as far as I tested, there still remained some branches even when no isthmus points were preserved.
Some of the remaining branches end with a specific configuration depicted in the figure below.

[http://simple-voxels.googlecode.com/svn/wiki/images/neighbor-not-removed.png]

It turned out that this configuration is the one that Lohou and Bertrand illustrated in [Top#References [3]]
as an example configuration that is not removed by [PalagyiKuba Palagyi and Kuba]'s method whereas can be removed by their method.

They derived a more-deleting deletable condition based on a powerful notion called _Px-simple_,
which allows one to devise a new parallel thinning algorithm without verifying
the consistency of the set of matching templates one-by-one that the parallel removal does not break the object topology.

In the rest of this page, after their deletable condition is briefly explained,
an implementation will be proposed using direct bit operations and supplemental template matching.

= Deletable Condition based on P2x-simple Points =
In the following, the description assumes the U-direction.
For other directions, the condition will immediately follow
by rotating the 3x3x3 neighborhood configuration.

== P2-simple ==
A point x is called P2-simple if:
  # Its U-neighbor is white.
  # If any of its N/S/W/E-neighbor is white, then the neighbor's U-neighbor is also white.

In the figure below, the black point denotes the point x.
The first condition requires the point above x be white.
The second condition says that if a yellow position is white,
then its U-neighbor (the gray position above it) should be white, too.

[http://simple-voxels.googlecode.com/svn/wiki/images/neighbor-p2simple.png]

== P2x-simple ==
Given a center point x, its 26-neighborhood points are called P2x-simple
if it is not denied that they are P2-simple within the 3x3x3 neighborhood of x.
In other words, a 26-neighbor point of x is not P2x-simple if it disqualifies the P2-simple condition even in the 3x3x3 neighborhood of x.

Based on the P2x-simple condition, black points in the 3x3x3 neighborhood of x are divided into the following two sets.
  * Px : the set of black points that are P2x-simple
  * Rx : the set of black points that are not P2x-simple

Note that any black point in the top plane is always P2x-simple because
the points above it and its N/S/W/E-neighbors are outside the 3x3x3 neighborhood of x, the P2-simple condition for the black point may not be denied.

== Deletable Condition ==
Now, a point x is deletable if the following conditions are fulfilled.
  * (P2) x is P2-simple
  * (C1) The number of 26-connected components in Rx is 1.
  * (C2) The number of 6-connected white (background) components within the 18-neighborhood of x is 1.
  * (C3) For every point y in Px, there exists z in Rx such that z is 26-adjacent to both x and y.
  * (C4) For every point y in Px that is 6-adjacent to x, there exist white points z and t such that {x, y, z, t} forms a unit square.

As is shown in the next section, with this deletable condition, 6,129,532 points are deletable for one direction whereas 2,124,292 points are deletable with the [PalagyiKuba Palagyi and Kuba]'s condition.
When all the six directions are considered,
23,722,000 points are deletable whereas 9,196,926 points are
deletable with [PalagyiKuba Palagyi and Kuba]'s condition.

= Proposed Method =
In [Top#References [3]], the authors proposed the use two binary decision diagrams to determine if a point is deletable or not with the above condition.

I was again interested in devising matching templates for the above deletable conditions
but failed to find such a single set of matching templates for the deletable condition as a whole.
So, I decided to look into each condition of P2, C1/2/3/4 one by one.

== C4 ==
First of all, the number of configurations that satisfy each conditions was investigated.

[http://simple-voxels.googlecode.com/svn/wiki/images/pxcondition-stat.png]

where bit0 - bit5 denotes the following conditions:
|| *Bit* || *Condition* || 
|| bit0 || deletable ||
|| bit1  || P2 ||
|| bit2  || C1 ||
|| bit3  || C2 ||
|| bit4  || C3 ||
|| bit5  || C4 ||

From the co-occurrence table above, it can be seen that C4 is always satisfied if P2 is satisfied.
The condition C4 can therefore be omitted.

== P2 : x is P2-simple ==
The matching templates for the P2 condition are straight forward from the definition of P2-simple condition.
Hence, it would be efficient to check the P2 condition first,
and to simplify the matching templates for other conditions by using the configurations for which P2 fails as the _don't care_ configurations.

However, even with this technique, the matching templates for C1 and C3 were still hard to find out primarily because they are talking about Px and Rx whereas the matching templates are tested with the original x neighborhood.

On the other hand, the set Px or Rx can be calculated by rather simple bit operations, and it can compute the P2 condition at the same time.
With Px and Rx, the matching templates for the conditions C1 and C3 are expected to be practically simple.

Given a configuration as an 32-bit integer _bits_, the following code computes the Px for the U direction.
Please see [Notations] for the bit assignment of positions within _bits_.
{{{
enum {
    DX = 1,
    DY = 3,
    DZ = 9,
};

const int MaskW = BV( BP(3,3,3), BP(3,3,3), BP(3,3,3) );    // West
const int MaskE = BV( BP(6,6,6), BP(6,6,6), BP(6,6,6) );    // East
const int MaskN = BV( BP(7,7,0), BP(7,7,0), BP(7,7,0) );    // North
const int MaskS = BV( BP(0,7,7), BP(0,7,7), BP(0,7,7) );    // South

int CalcP2x( int bits ) {
    const int top = bits << DZ;
    const int mid = top & ~bits;
    const int rx = top | ((mid & MaskE) >> DX) | ((mid & MaskW) << DX) | ((mid & MaskS) >> DY) | ((mid & MaskN) << DY);
    return bits & ~rx;
}}}

The above code first computes the set Rx. By negating the P2-simple condition, the condition for a black point to belong to Rx is obtained as:
  # Its U-neighbor is a black point.
  # Or, any of its N/S/W/E neighbors is white, and the neighbor's U-neighbor is black.

Now, what the code is doing is as follows:
  * _top_ holds the value of the U-neighbor of each position by shifting _bits_ by DZ = 9 bits.
  * _mid_ holds '1' bits where the corresponding points are white '0' and their U-neighbor is black '1'.
  * _rx_ then has '1' bits if the U-neighbor of the corresponding bits is black '1', or any of their N/S/W/E neighbors are white '0' and its U-neighbor is black '1'.

Finally, Px is obtained by negating _rx_.

The P2 condition can be checked by looking at the Px bit that corresponds to the center position.

== C3 : Px points are 26-adjacent to a Rx point ==
The C3 condition requires that for any P2x simple point other than x,
there can be found a Rx point in its 26-neighborhood.
Therefore, this condition can be checked by
  # Compute rn = 26-inflate of rx
  # If rn has '0' bit at any position for which px has '1' bit , C3 fails.
{{{
enum {
    N0_bits  = BV( BP(0,0,0), BP(0,2,0), BP(0,0,0) ),
};
//...
    int rn = rx;    // N26( rx )
    rn = rn | ((rn & MaskE) >> DX) | ((rn & MaskW) << DX);
    rn = rn | ((rn & MaskS) >> DY) | ((rn & MaskN) << DY);
    rn = rn | (rn >> DZ) | (rn << DZ);
    if (~rn & px & ~N0_bits) return false;
//...
}}}

== C2: exactly one background component ==
Under the condition that the x is P2-simple,
the C2 condition turned out to be reduced to the following two templates.
Note that because x is P2-simple, its U-neighbor, the top center point, is white for both of the templates.
Also note that, if its N/S/W/E neighbor is white, their U-neighbor is white, too.

[http://simple-voxels.googlecode.com/svn/wiki/images/pxsimple-t6nx-masks.png]

=== When bottom center is black (left) ===
When the bottom center point is black, the C2 condition is always satisfied as long as x is P2-simple.
This is because, if any N/S/W/E neighbor of x is white, its U-neighbor is also white due to the P2-simplicity of x, and thus it is 6-connected with the top center white point.
This ensures that there is exactly one background component.

=== When bottom center is white (right) ===
On the other hand, when the bottom center point is white, it should be connected with the top center white point because the C2 condition requires the number of background points to be one.
Also because the component is 6-connected, there should be a white column in any of N/S/W/E neighborhood of x.
Again due to the P2-simplicity of x, the right template is enough
to ensure that there is exactly one background component in this case.

== C1 : exactly one 26-connected Rx component ==
First of all, all the black points in the top plane is P2x-simple.
Rx points exist in the middle or the bottom planes only.

=== When bottom center is black ===
The C1 condition will always be satisfied because the bottom center is a Rx point and there is no Rx point on the top plane,
all the Rx points will be 26-adjacent to the bottom center.

=== When bottom center is white ===
In this case, similar to the [RaynalCouprie isthmus templates],
I figured out matching templates for Rx points to be divided into at least two components.
If a configuration matches to any of the following two templates,
the C1 condition will fail.

[http://simple-voxels.googlecode.com/svn/wiki/images/pxsimple-t26rx-masks.png]

{{{
namespace NPxSimple {// P2x-simple
    const Mask TemplatesT26Rx[2] = {
        Mask( BV( BP(0,0,0), BP(2,0,2), BP(2,2,2) ), 0, BV( BP(0,0,0), BP(1,1,1), BP(1,1,1) ), BV( BP(0,0,0), BP(4,4,4), BP(4,4,4) ) ),
        Mask( BV( BP(0,0,0), BP(2,1,0), BP(2,3,0) ), 0, BV( BP(0,0,0), BP(1,0,0), BP(1,0,0) ), BV( BP(0,0,0), BP(4,4,7), BP(4,4,7) ) ),
    };
}
}}}

[http://simple-voxels.googlecode.com/svn/wiki/images/pxsimple-t26rx-templates.png]

== Implementation ==
{{{
const Mask pxsimple_T26Rx_tables[][6] = {
    {// dir = 0
        // M1
        Mask( BV( BP(0,0,0), BP(2,0,2), BP(2,2,2) ), 0, BV( BP(0,0,0), BP(1,1,1), BP(1,1,1) ), BV( BP(0,0,0), BP(4,4,4), BP(4,4,4) ) ),
        Mask( BV( BP(0,0,0), BP(0,5,0), BP(0,7,0) ), 0, BV( BP(0,0,0), BP(7,0,0), BP(7,0,0) ), BV( BP(0,0,0), BP(0,0,7), BP(0,0,7) ) ),
        // M2
        Mask( BV( BP(0,0,0), BP(2,1,0), BP(2,3,0) ), 0, BV( BP(0,0,0), BP(1,0,0), BP(1,0,0) ), BV( BP(0,0,0), BP(4,4,7), BP(4,4,7) ) ),
        Mask( BV( BP(0,0,0), BP(2,4,0), BP(2,6,0) ), 0, BV( BP(0,0,0), BP(4,0,0), BP(4,0,0) ), BV( BP(0,0,0), BP(1,1,7), BP(1,1,7) ) ),
        Mask( BV( BP(0,0,0), BP(0,4,2), BP(0,6,2) ), 0, BV( BP(0,0,0), BP(0,0,4), BP(0,0,4) ), BV( BP(0,0,0), BP(7,1,1), BP(7,1,1) ) ),
        Mask( BV( BP(0,0,0), BP(0,1,2), BP(0,3,2) ), 0, BV( BP(0,0,0), BP(0,0,1), BP(0,0,1) ), BV( BP(0,0,0), BP(7,4,4), BP(7,4,4) ) ),
    },
//...
};

const int MaskT6N4 = BV( BP(0,0,0), BP(2,5,2), BP(0,0,0) );
const int MaskBtm  = BV( BP(0,0,0), BP(0,0,0), BP(0,2,0) );

bool IsP2xSimpleU( int bits ) {
    const int top = (bits << DZ);
    const int mid = (bits << DZ) & ~bits;
    const int rx = bits & (top | ((mid & MaskE) >> DX) | ((mid & MaskW) << DX) | ((mid & MaskS) >> DY) | ((mid & MaskN) << DY));
    const int px = bits & ~rx;
    if (rx == 0) return false;              // C1
    if ((px & N0_bits) == 0) return false;  // x is P2?
    {// C3
        int rn = rx;    // N26(Rx)
        rn = rn | ((rn & MaskE) >> DX) | ((rn & MaskW) << DX);
        rn = rn | ((rn & MaskS) >> DY) | ((rn & MaskN) << DY);
        rn = rn | (rn >> DZ) | (rn << DZ);
        if (~rn & px & ~N0_bits) return false;
    }
    if ((bits & MaskBtm) == 0) {// the bottom center is white
        {// C2
            const int n4 = ~(bits | (bits >> DZ));
            if ((n4 & MaskT6N4) == 0) return false;
        }
        {// C1
            for each (const Mask& mask in pxsimple_T26Rx_tables[ED_U]) {
                if (mask.Match( rx )) return false;
            }
        }
    }
    return true;
}
}}}

= Statistics =
The table below shows how many simple configurations can be deleted by the P2x-simple condition for each of the six directions: 

[http://simple-voxels.googlecode.com/svn/wiki/images/pxsimple-stat.png]

where bit0 - bit5 denotes the following directions:
|| *Bit* || *Direction* ||
|| bit0 || U ||
|| bit1 || D ||
|| bit2 || N ||
|| bit3 || S ||
|| bit4 || W ||
|| bit5 || E ||

It can be observed that
  * As a whole, 23,722,000 out of 25,985,144 [SimpleVoxels#Simple_Configurations simple] configurations are deletable.
  * For each direction, 6,129,532 configurations are deletable.
  * Between the opposite directions such as U and D, 641,232 configurations are deletable in common. (Likewise, between N and S or between W and E.)

= Proposal for Ultimate Thinning =
Compared with [PalagyiKuba Palagyi and Kuba]'s method and [RaynalCouprie Raynal and Couprie]'s method,
the above deletable condition allows to remove more than twice number of simple voxels.
However, there were found some configuration that are deletable by [RaynalCouprie Raynal and Couprie]'s method, but not by this method as follows:
 
[http://simple-voxels.googlecode.com/svn/wiki/images/raynal-pxsimple.png]

Namely, the diagonal end point depicted in the figure below is not deletable.

[http://simple-voxels.googlecode.com/svn/wiki/images/neighbor-diag-end.png]

One would want to delete the above configurations too if this method is to be used for the [LohouBertrand#Introduction ultimate thinning] purpose, Assume that the above template is further added to the set of deletable configuration for the U direction. If the bottom black point is not deletable in any case, this extension does not break the parallel thinning nature. 

The above configuration looks like the next one when checking the deletable condition for the bottom black point.

[http://simple-voxels.googlecode.com/svn/wiki/images/neighbor-diag-end-opp.png]

In this configuration, because the black point at the top is P2x-simple and because there is no Rx point in its 26-neighborhood, the C3 condition does not hold.

Therefore the diagonal end point can be deleted safely.