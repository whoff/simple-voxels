#summary Lohou and Bertrand P2x-simple thinning algorithm
*Contents*
<wiki:toc max_depth="2" />

= Introduction =
By using [RaynalCouprie Raynal and Couprie]'s method,
a considerable amount of spurious brances will be reduced.
In addition, as was suggested in [Top#References [2]],
if the isthmus points were not preserved but removed,
all the skeletal branches would also be removed resulting in _ultimate thinning_,
where no more points can be removed without breaking the topology.
An ultimately thinned object has no branches and is composed of circular curves or cocoon like shells.

However, as far as I tested, there still remained some branches even when the isthmus points were removed.
Some of the remaining branches end with a specific configuration depicted in the figure below.

[http://simple-voxels.googlecode.com/svn/wiki/images/neighbor-not-removed.png]

It turned out that this configuration is one of those that are pointed out
to be non-deletable by [PalagyiKuba Palagyi and Kuba]'s method [Top#References [3]].

In [Top#References [3]], Lohou and Bertrand proposed another
deletable condition based on a powerful notion of _Px-simple_,
with which one can devise a new parallel thinning algorithm without checking
whether its matching templates are consistent to allow parallel removal of deletable points while preserving topology.

In the rest of this page, after the deletable condition is briefly explained,
an implementation will be proposed using direct bit operations and supplement template matching.

= Definition =
== P2-simple ==
To begin with, a point x is called P2-simple, as regards the U direction for example, if:
  # U neighbor is white.
  # If N/S/W/E neighbor is white, then its U neighbor of is also white.

In the figure below, the second condition says that if a yellow point is white (background), then its U-neighbor gray point should be white (background).

[http://simple-voxels.googlecode.com/svn/wiki/images/neighbor-p2simple.png]

== P2x-simple ==
For points in the 26-neighborhood of x, they are called P2x-simple,
if they may be P2-simple when looking at the 3x3x3 neighborhood of x only.

Or in other words, a 26-neighborhood of x is not P2x-simple
if it does not satisfy the P2-simple condition already in the 3x3x3 neighborhood of x.

Here are defined following two sets of black points:
  * Px : the set of black points in the 3x3x3 neighborhood of x that are P2x-simple
  * Rx : the set of black points in the 3x3x3 neighborhood of x that are not P2x-simple

== Deletable Condition ==
A point x is deletable if the following conditions are all satisfied.
  * (P2) x is P2-simple
  * (C1) The number of 26-connected components in Rx is 1.
  * (C2) The number of 6-connected white components within 18-neighborhood of x is 1.
  * (C3) For every point y in Px, there exists z in Rx such that z is 26-adjacent to x and to y.
  * (C4) For every point y in Px that is 6-adjacent to x, there exist white points z and t such that {x, y, z, t} forms a unit square.

With this deletable condition, for the U-direction for example,
6,129,532 points are deletable whereas 2,124,292 points are deletable with the [PalaghiKuba Palagyi and Kuba]'s condition.
When all the six directions are considered,
23,722,000 points are deletable whereas 9,196,926 points are
deletable with Palagyi and Kuba's condition.

= Proposed Method =
In [Top#References [3]], the authors proposed the use two binary decision diagrams to determine if a point is deletable or not with the above condition.

I was again interested in devising matching templates for the above deletable conditions
but failed to find such a single set of matching templates for the deletable condition as a whole.
So, I decided to look into each condition of P2, C1/2/3/4 one by one.

== C4 ==
First of all, the number of configurations that satisfy each conditions was investigated.

[http://simple-voxels.googlecode.com/svn/wiki/images/pxcondition-stat.png]

where bit0 - bit5 denotes the following conditions:
|| *Bit* || *Condition* || 
|| bit0 || deletable ||
|| bit1  || P2 ||
|| bit2  || C1 ||
|| bit3  || C2 ||
|| bit4  || C3 ||
|| bit5  || C4 ||

From the co-occurrence table above, it can be seen that C4 is always satisfied if P2 is satisfied.
The condition C4 can therefore be omitted.

== P2 : x is P2-simple ==
The matching templates for the P2 condition are straight forward from the definition of P2-simple condition.
Hence, it would be efficient to check the P2 condition first,
and to simplify the matching templates for other conditions by using the configurations for which P2 fails as the _don't care_ configurations.

However, even with this technique, the matching templates for C1 and C3 were still hard to find out primarily because they are talking about Px and Rx whereas the matching templates are tested with the original x neighborhood.

On the other hand, the set Px or Rx can be calculated by rather simple bit operations, and it can compute the P2 condition at the same time.
With Px and Rx, the matching templates for the conditions C1 and C3 are expected to be practically simple.

Given a configuration as an 32-bit integer _bits_, the following code computes the Px for the U direction.
Please see [Notations] for the bit assignment of positions within _bits_.
{{{
enum {
    DX = 1,
    DY = 3,
    DZ = 9,
};

const int MaskW = BV( BP(3,3,3), BP(3,3,3), BP(3,3,3) );    // West
const int MaskE = BV( BP(6,6,6), BP(6,6,6), BP(6,6,6) );    // East
const int MaskN = BV( BP(7,7,0), BP(7,7,0), BP(7,7,0) );    // North
const int MaskS = BV( BP(0,7,7), BP(0,7,7), BP(0,7,7) );    // South

int CalcP2x( int bits ) {
    const int top = bits << DZ;
    const int mid = top & ~bits;
    const int rx = top | ((mid & MaskE) >> DX) | ((mid & MaskW) << DX) | ((mid & MaskS) >> DY) | ((mid & MaskN) << DY);
    return bits & ~rx;
}}}

The above code first computes the set Rx. By negating the P2-simple condition, the condition for a black point to belong to Rx is obtained as:
  # Its U-neighbor is a black point.
  # Or, any of its N/S/W/E neighbors is white, and the neighbor's U-neighbor is black.

Now, what the code is doing is as follows:
  * _top_ holds the value of the U-neighbor of each position by shifting _bits_ by DZ = 9 bits.
  * _mid_ holds '1' bits where the corresponding points are white '0' and their U-neighbor is black '1'.
  * _rx_ then has '1' bits if the U-neighbor of the corresponding bits is black '1', or any of their N/S/W/E neighbors are white '0' and its U-neighbor is black '1'.

Finally, Px is obtained by negating _rx_.

The P2 condition can be checked by looking at the Px bit that corresponds to the center position.

== C3 : Px points are 26-adjacent to a Rx point ==
The C3 condition requires that for any P2x simple point other than x,
there can be found a Rx point in its 26-neighborhood.
Therefore, this condition can be checked by
  # Compute rn = 26-inflate of rx
  # If rn has '0' bit at any position for which px has '1' bit , C3 fails.
{{{
enum {
    N0_bits  = BV( BP(0,0,0), BP(0,2,0), BP(0,0,0) ),
};
//...
    int rn = rx;    // N26( rx )
    rn = rn | ((rn & MaskE) >> DX) | ((rn & MaskW) << DX);
    rn = rn | ((rn & MaskS) >> DY) | ((rn & MaskN) << DY);
    rn = rn | (rn >> DZ) | (rn << DZ);
    if (~rn & px & ~N0_bits) return false;
//...
}}}

== C2: exactly one background component ==
Under the condition that the x is P2-simple,
the C2 condition turned out to be reduced to the following two templates.
Note that because x is P2-simple, its U-neighbor, the top center point, is white for both of the templates.
Also note that, if its N/S/W/E neighbor is white, their U-neighbor is white, too.

[http://simple-voxels.googlecode.com/svn/wiki/images/pxsimple-t6nx-masks.png]

=== Left template ===
When the bottom center point is black, the C2 condition is always satisfied as long as x is P2-simple.
This is because, if any N/S/W/E neighbor of x is white, its U-neighbor is also white due to the P2-simplicity of x, and thus it is 6-connected with the top center white point.
This ensures that there is exactly one background component.

=== Right template ===
On the other hand, when the bottom center point is white, it should be connected with the top center white point because the C2 condition requires the number of background points to be one.
Also because the component is 6-connected, there should be a white column in any of N/S/W/E neighborhood of x.
Again due to the P2-simplicity of x, the right template is enough
to ensure that there is exactly one background component in this case.

== C1 : exactly one 26-connected Rx component ==
First of all, all the black points in the top plane is P2x-simple.
Rx points exist in the middle or the bottom planes only.

The C1 condition requires that the number of 26-connected components in Rx is one.
Similar to the [RaynalCouprie isthmus templates],
I figured out matching templates for Rx points to be divided into at least two components.
If a configuration matches to any of the following two templates,
the C1 condition will fail.

[http://simple-voxels.googlecode.com/svn/wiki/images/pxsimple-t26rx-masks.png]

{{{
namespace NPxSimple {// P2x-simple
    const Mask TemplatesT26Rx[2] = {
        Mask( BV( BP(0,0,0), BP(2,0,2), BP(2,2,2) ), 0, BV( BP(0,0,0), BP(1,1,1), BP(1,1,1) ), BV( BP(0,0,0), BP(4,4,4), BP(4,4,4) ) ),
        Mask( BV( BP(0,0,0), BP(2,1,0), BP(2,3,0) ), 0, BV( BP(0,0,0), BP(1,0,0), BP(1,0,0) ), BV( BP(0,0,0), BP(4,4,7), BP(4,4,7) ) ),
    };
}
}}}

[http://simple-voxels.googlecode.com/svn/wiki/images/pxsimple-t26rx-templates.png]

== Statistics ==

[http://simple-voxels.googlecode.com/svn/wiki/images/pxsimple-stat.png]

[http://simple-voxels.googlecode.com/svn/wiki/images/raynal-pxsimple.png]