#summary Lohou and Bertrand P2x-simple thinning algorithm
*Contents*
<wiki:toc max_depth="2" />

= Introduction =
By using [RaynalCouprie Raynal and Couprie]'s method,
a considerable amount of spurious brances will be reduced.
In addition, as was suggested in [Top#References [2]],
if the isthmus points were not preserved but removed,
all the skeletal branches would also be removed resulting in _ultimate thinning_,
where no more points can be removed without breaking the topology.
An ultimately thinned object has no branches and is composed of circular curves or cocoon like shells.

However, as far as I tested, there still remained some branches even when the isthmus points were removed.
Some of the remaining branches end with a specific configuration depicted in the figure below.

[http://simple-voxels.googlecode.com/svn/wiki/images/neighbor-not-removed.png]

It turned out that this configuration is one of those that are pointed out
to be non-deletable by [PalagyiKuba Palagyi and Kuba]'s method [Top#References [3]].

In [Top#References [3]], Lohou and Bertrand proposed another
deletable condition based on a powerful notion of _Px-simple_,
with which one can devise a new parallel thinning algorithm without checking
whether its matching templates are consistent to allow parallel removal of deletable points while preserving topology.

In the rest of this page, after the deletable condition is briefly explained,
an implementation will be proposed using direct bit operations and supplement template matching.

= Definition =
== P2-simple ==
To begin with, a point x is called P2-simple, as regards the U direction for example, if:
  # U neighbor is white.
  # If N/S/W/E neighbor is white, then the point above it is also white.

In the figure below, the second condition says that if a yellow point is white, then the gray point above it should be white.

[http://simple-voxels.googlecode.com/svn/wiki/images/neighbor-p2simple.png]

== P2x-simple ==
For points in the 26-neighborhood of x, they are called P2x-simple,
if they may be P2-simple when looking at the 3x3x3 neighborhood of x only.

Or in other words, a 26-neighborhood of x is not P2x-simple
if it does not satisfy the P2-simple condition already in the 3x3x3 neighborhood of x.

Here are defined following two sets of black points:
  * Px : the set of black points in the 3x3x3 neighborhood of x that are P2x-simple
  * Rx : the set of black points in the 3x3x3 neighborhood of x that are not P2x-simple

== Deletable Condition ==
A point x is deletable if the following conditions are all satisfied.
  * (P2) x is P2-simple
  * (C1) The number of 26-connected components in Rx is 1.
  * (C2) The number of 6-connected white components within 18-neighborhood of x is 1.
  * (C3) For every point y in Px, there exists z in Rx such that z is 26-adjacent to x and to y.
  * (C4) For every point y in Px that is 6-adjacent to x, there exist white points z and t such that {x, y, z, t} forms a unit square.

With this deletable condition, for the U-direction for example,
6,129,532 points are deletable whereas 2,124,292 points are deletable with the [PalaghiKuba Palagyi and Kuba]'s condition.
When all the six directions are considered,
23,722,000 points are deletable whereas 9,196,926 points are
deletable with Palagyi and Kuba's condition.

= Proposed Method =
In [Top#References [3]], the authors proposed the use two binary decision diagrams to determine if a point is deletable or not with the above condition.

I was again interested in devising matching templates for the above deletable conditions but failed to find such a single set of matching templates for the deletable condition as a whole.
So, I decided to look into each condition of P2, C1/2/3/4 one by one.

== C4 ==
First of all, the number of configurations that satisfy each conditions was investigated.

[http://simple-voxels.googlecode.com/svn/wiki/images/pxcondition-stat.png]

where bit0 - bit5 denotes the following conditions:
|| *Bit* || *Condition* || 
|| bit0 || deletable ||
|| bit1  || P2 ||
|| bit2  || C1 ||
|| bit3  || C2 ||
|| bit4  || C3 ||
|| bit5  || C4 ||

From the co-occurrence table above, it can be seen that C4 is always satisfied if P2 is satisfied.
The condition C4 can therefore be ignored.

== P2 ==
The matching templates for P2 condition are straight forward from the definition of P2 simple.
Hence, it would be efficient to check the P2 condition first because the matching templates for other conditions would be simplified by using the configurations for which P2 fails as the _don't care_ configurations.

However, even with this technique, the matching templates for C1 and C3 were still hard to find primarily because they are talking about Px and Rx whereas the matching templates are for the original x neighborhood.

On the other hand, the set Px or Rx can be calculated by simple bit operations, and it can compute the P2 condition at the same time.
With Px and Rx, the matching templates for the conditions C1 and C3 are expected to be practically simple.

The code below computes the Px for the U direction given a configuration as an 32-bit integer _bits_.
Please see [Notations] for the bit assignment of positions within _bits_.
{{{
enum {
    DX = 1,
    DY = 3,
    DZ = 9,
};

const int MaskW = BV( BP(3,3,3), BP(3,3,3), BP(3,3,3) );    // West
const int MaskE = BV( BP(6,6,6), BP(6,6,6), BP(6,6,6) );    // East
const int MaskN = BV( BP(7,7,0), BP(7,7,0), BP(7,7,0) );    // North
const int MaskS = BV( BP(0,7,7), BP(0,7,7), BP(0,7,7) );    // South

int CalcP2x( int bits ) {
    const int top = bits << DZ;
    const int mid = top & ~bits;
    const int rx = top | ((mid & MaskE) >> DX) | ((mid & MaskW) << DX) | ((mid & MaskS) >> DY) | ((mid & MaskN) << DY);
    return bits & ~rx;
}}}



{{{
namespace NPxSimple {// P2x-simple
    const Mask TemplatesT26Rx[2] = {
        Mask( BV( BP(0,0,0), BP(2,0,2), BP(2,2,2) ), 0, BV( BP(0,0,0), BP(1,1,1), BP(1,1,1) ), BV( BP(0,0,0), BP(4,4,4), BP(4,4,4) ) ),
        Mask( BV( BP(0,0,0), BP(2,1,0), BP(2,3,0) ), 0, BV( BP(0,0,0), BP(1,0,0), BP(1,0,0) ), BV( BP(0,0,0), BP(4,4,7), BP(4,4,7) ) ),
    };
}
}}}


[http://simple-voxels.googlecode.com/svn/wiki/images/pxsimple-t26rx-masks.png]

[http://simple-voxels.googlecode.com/svn/wiki/images/pxsimple-t26rx-templates.png]

[http://simple-voxels.googlecode.com/svn/wiki/images/pxsimple-stat.png]

[http://simple-voxels.googlecode.com/svn/wiki/images/raynal-pxsimple.png]